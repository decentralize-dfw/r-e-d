<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>C2W2 Virtual Runway - Premium Edition</title>

    <style>
        :root {
            --fg: #ffffff;
            --bg: #000000;
            --panel-bg: rgba(10, 10, 15, 0.75);
            --panel-border: rgba(255, 255, 255, 0.08);
            --panel-blur: 20px;
            --transition-smooth: cubic-bezier(0.4, 0, 0.2, 1);
            --transition-bounce: cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            color: var(--fg);
            background: var(--bg);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            cursor: pointer;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
        }

        /* Loading */
        #loading {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.95);
            z-index: 1000;
            transition: opacity 0.8s ease;
        }

        #loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: #ffffff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 30px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 16px;
            font-weight: 300;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 10px;
        }

        .loading-progress {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.5);
            letter-spacing: 1px;
        }

        #backgroundImg {
            position: fixed;
            inset: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 5;
            display: none;
            transition: opacity 0.8s ease;
        }

        #sceneLoadingIndicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: #ffffff;
            padding: 20px 40px;
            border-radius: 8px;
            font-size: 16px;
            letter-spacing: 2px;
            z-index: 1001;
            display: none;
            backdrop-filter: blur(10px);
        }

        /* Instructions */
        #instructions {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: var(--panel-bg);
            backdrop-filter: blur(var(--panel-blur));
            border: 1px solid var(--panel-border);
            border-radius: 16px;
            padding: 40px 60px;
            z-index: 15;
            display: none;
            transition: all 0.5s var(--transition-smooth);
        }

        #instructions.visible {
            display: block;
        }

        #instructions h1 {
            font-size: 32px;
            font-weight: 200;
            letter-spacing: 6px;
            text-transform: uppercase;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #fff 0%, rgba(255, 255, 255, 0.7) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        #instructions p {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.6);
            letter-spacing: 1px;
        }

        /* Control Buttons */
        .control-btn {
            backdrop-filter: blur(var(--panel-blur));
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            color: var(--fg);
            padding: 12px 20px;
            font-size: 13px;
            font-weight: 500;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s var(--transition-smooth);
            font-family: inherit;
            text-transform: uppercase;
            white-space: nowrap;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .control-btn.selected {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
        }

        #startButton {
            position: fixed;
            left: 20px;
            bottom: 20px;
            z-index: 10;
            display: none;
            padding: 16px 40px;
            font-size: 14px;
        }

        #modelLabel {
            position: fixed;
            left: 20px;
            top: 20px;
            color: var(--fg);
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 2px;
            text-transform: uppercase;
            z-index: 10;
            display: none;
        }

        #modelToggleContainer {
            position: fixed;
            top: 20px;
            left: 80px;
            right: 20px;
            z-index: 10;
            display: none;
            flex-wrap: wrap;
            gap: 10px;
            align-items: flex-start;
        }

        #modelToggleContainer.visible {
            display: flex;
        }

        .model-toggle-btn {
            padding: 10px 16px;
            font-size: 12px;
        }

        /* Description */
        #description {
            position: fixed;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            max-width: 600px;
            text-align: center;
            padding: 16px 28px;
            backdrop-filter: blur(var(--panel-blur));
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: 12px;
            z-index: 10;
            font-size: 15px;
            letter-spacing: 0.5px;
            display: none;
            transition: all 0.4s var(--transition-smooth);
        }

        /* HTML Panels */
        #leftHtmlPanel, #rightHtmlPanel {
            position: fixed;
            width: 280px;
            top: 100px;
            bottom: 140px;
            overflow-y: auto;
            backdrop-filter: blur(var(--panel-blur));
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: 12px;
            padding: 24px;
            z-index: 10;
            font-size: 14px;
            line-height: 1.6;
            display: none;
            transition: all 0.5s var(--transition-bounce);
        }

        #leftHtmlPanel {
            left: 20px;
            transform: translateX(-350px);
        }

        #leftHtmlPanel.visible {
            transform: translateX(0);
            display: block;
        }

        #rightHtmlPanel {
            right: 20px;
            transform: translateX(350px);
        }

        #rightHtmlPanel.visible {
            transform: translateX(0);
            display: block;
        }

        #leftHtmlPanel::-webkit-scrollbar,
        #rightHtmlPanel::-webkit-scrollbar {
            width: 4px;
        }

        #leftHtmlPanel::-webkit-scrollbar-thumb,
        #rightHtmlPanel::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }

        #leftHtmlPanel h3, #rightHtmlPanel h3 {
            margin: 0 0 16px 0;
            font-size: 18px;
            font-weight: 300;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        #leftHtmlPanel p, #rightHtmlPanel p {
            color: rgba(255, 255, 255, 0.8);
            margin: 10px 0;
        }

        .hidden { display: none !important; }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading Experience</div>
        <div class="loading-progress" id="loadingProgress">Preparing assets...</div>
    </div>

    <!-- Background Image -->
    <img id="backgroundImg" src="https://raw.githubusercontent.com/decentralize-dfw/vea_001/main/VEADEMO1.jpg" alt="Background">

    <!-- Scene Loading Indicator -->
    <div id="sceneLoadingIndicator">LOADING SCENE...</div>

    <!-- Instructions -->
    <div id="instructions">
        <h1>Click to Enter</h1>
        <p>Experience begins in a moment</p>
    </div>

    <!-- Controls -->
    <button id="startButton" class="control-btn">Start Experience</button>

    <div id="modelLabel">Model</div>
    <div id="modelToggleContainer">
        <button id="modelToggleBtn1" class="control-btn model-toggle-btn">Option 1</button>
        <button id="modelToggleBtn2" class="control-btn model-toggle-btn">Option 2</button>
        <button id="modelToggleBtn3" class="control-btn model-toggle-btn">Option 3</button>
        <button id="modelToggleBtn4" class="control-btn model-toggle-btn">Option 4</button>
        <button id="modelToggleBtn5" class="control-btn model-toggle-btn">Option 5</button>
        <button id="modelToggleBtn6" class="control-btn model-toggle-btn">Option 6</button>
    </div>

    <!-- Description -->
    <div id="description"></div>

    <!-- Side HTML Panels -->
    <div id="leftHtmlPanel"></div>
    <div id="rightHtmlPanel"></div>

    <!-- HTML Content Store -->
    <div id="htmlContentStore" style="display: none;">
        <div id="html_scene0_left">
            <h3>Welcome</h3>
            <p>Auto-rotating view of the architectural concept.</p>
        </div>
        <div id="html_scene0_right">
            <h3>Overview</h3>
            <p>Isometric presentation of the complete design.</p>
        </div>

        <div id="html_scene1_opt1_left">
            <h3>Surrounding</h3>
            <p>Neighborhood and urban context.</p>
        </div>
        <div id="html_scene1_opt1_right">
            <h3>Urban Integration</h3>
            <p>Site location and environment.</p>
        </div>

        <div id="html_scene1_opt2_left">
            <h3>Transportation</h3>
            <p>Metro: 5 min | Shopping: 17 min | Center: 10 min</p>
        </div>
        <div id="html_scene1_opt2_right">
            <h3>Connectivity</h3>
            <p>Excellent public transport access.</p>
        </div>

        <div id="html_scene1_opt3_left">
            <h3>Units</h3>
            <p>Variety of apartment configurations.</p>
        </div>
        <div id="html_scene1_opt3_right">
            <h3>Living Spaces</h3>
            <p>Flexible floor plans for modern living.</p>
        </div>

        <div id="html_scene2_opt1_left">
            <h3>Design Option 1</h3>
            <p>White facade with clean aesthetics.</p>
        </div>
        <div id="html_scene2_opt1_right">
            <h3>Material Palette</h3>
            <p>High-quality finishes.</p>
        </div>

        <div id="html_scene2_opt2_left">
            <h3>Design Option 2</h3>
            <p>Metal facade with bold expression.</p>
        </div>
        <div id="html_scene2_opt2_right">
            <h3>Alternative</h3>
            <p>Different material approach.</p>
        </div>

        <div id="html_scene3_left">
            <h3>Structure</h3>
            <p>Ghost view revealing internal organization.</p>
        </div>
        <div id="html_scene3_right">
            <h3>Technical</h3>
            <p>Building systems and circulation.</p>
        </div>

        <div id="html_scene4_cam1_left"><h3>Living Room</h3><p>Main living space.</p></div>
        <div id="html_scene4_cam1_right"><h3>Salon</h3><p>Natural light.</p></div>
        <div id="html_scene4_cam2_left"><h3>Kitchen</h3><p>Premium appliances.</p></div>
        <div id="html_scene4_cam2_right"><h3>Culinary</h3><p>Functional design.</p></div>
        <div id="html_scene4_cam3_left"><h3>Master Bedroom</h3><p>Private space.</p></div>
        <div id="html_scene4_cam3_right"><h3>Rest</h3><p>Comfort.</p></div>
        <div id="html_scene4_cam4_left"><h3>Master Bath</h3><p>Spa amenities.</p></div>
        <div id="html_scene4_cam4_right"><h3>Wellness</h3><p>Premium fixtures.</p></div>
        <div id="html_scene4_cam5_left"><h3>Second Bedroom</h3><p>Flexible space.</p></div>
        <div id="html_scene4_cam5_right"><h3>Additional</h3><p>Versatile.</p></div>
        <div id="html_scene4_cam6_left"><h3>Second Bath</h3><p>Full amenities.</p></div>
        <div id="html_scene4_cam6_right"><h3>Ensuite</h3><p>Complete.</p></div>

        <div id="html_scene5_left">
            <h3>Free Exploration</h3>
            <p>W/A/S/D to move. Shift: sprint. Space: jump.</p>
        </div>
        <div id="html_scene5_right">
            <h3>Walkthrough</h3>
            <p>Explore at your own pace.</p>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { SSAOPass } from 'three/addons/postprocessing/SSAOPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

        // ============================================
        // CONFIGURATION
        // ============================================
        const CONFIG = {
            models: [
                'https://raw.githubusercontent.com/decentralize-dfw/vea-randomfiles/main/DEMO2city-opt-v2.glb',
                'https://raw.githubusercontent.com/decentralize-dfw/vea-randomfiles/main/DEMO2city-ghost.glb',
                'https://raw.githubusercontent.com/decentralize-dfw/vea-randomfiles/main/DEMO2city-metal-v1.glb',
                'https://raw.githubusercontent.com/decentralize-dfw/vea-randomfiles/main/DEMO2city-whitefacade-v3.glb',
                'https://raw.githubusercontent.com/decentralize-dfw/vea-randomfiles/main/DEMO2kopuk-normalfacade-opt-v5.glb',
                'https://raw.githubusercontent.com/decentralize-dfw/vea-randomfiles/main/DEMO2-sehirici-apartmanici-opt-v6.glb',
                'https://raw.githubusercontent.com/decentralize-dfw/vea-randomfiles/main/DEMO2interior-soloapartement-opt-v4.glb',
                'https://raw.githubusercontent.com/decentralize-dfw/vea-randomfiles/main/SCENE5-COLLDERd.glb'
            ],
            hdri: 'https://raw.githubusercontent.com/decentralize-dfw/vea_001/main/RealismHDRI-_equirectangular-jpg_VR360_neon_drenched_skyscrapers_1656103290_10361044.hdr',
            dracoPath: 'https://www.gstatic.com/draco/versioned/decoders/1.5.7/',
            playerHeight: 1.6,
            playerRadius: 0.4,
            baseMoveSpeed: 20,
            sprintMultiplier: 4,
            jumpVelocity: 6,
            gravity: -20,
            defaultFOV: 75,
            orthoFrustumSize: 40
        };

        // ============================================
        // GLOBAL STATE
        // ============================================
        let scene, renderer, composer;
        let perspectiveCamera, orthographicCamera, camera;
        let orbitControls, pointerLockControls;
        let pmremGenerator, clock;
        let gltfLoader, audioListener;

        let currentScene = -1;
        let allModels = {}; // Store all pre-loaded models by index
        let colliderMeshes = [];
        let experienceStarted = false;
        let vrActive = false;
        let vrControllers = [];

        let playerVelocity = new THREE.Vector3();
        let playerOnFloor = false;
        let currentMoveSpeed = CONFIG.baseMoveSpeed;
        let keys = {
            forward: false, backward: false, left: false, right: false,
            jump: false, sprint: false
        };

        let raycaster = new THREE.Raycaster();
        let playerRig = new THREE.Group();

        // ============================================
        // DOM ELEMENTS
        // ============================================
        const DOM = {
            loading: document.getElementById('loading'),
            loadingProgress: document.getElementById('loadingProgress'),
            sceneLoading: document.getElementById('sceneLoadingIndicator'),
            backgroundImg: document.getElementById('backgroundImg'),
            instructions: document.getElementById('instructions'),
            startButton: document.getElementById('startButton'),
            modelLabel: document.getElementById('modelLabel'),
            modelToggleContainer: document.getElementById('modelToggleContainer'),
            modelToggles: [
                document.getElementById('modelToggleBtn1'),
                document.getElementById('modelToggleBtn2'),
                document.getElementById('modelToggleBtn3'),
                document.getElementById('modelToggleBtn4'),
                document.getElementById('modelToggleBtn5'),
                document.getElementById('modelToggleBtn6')
            ],
            description: document.getElementById('description'),
            leftPanel: document.getElementById('leftHtmlPanel'),
            rightPanel: document.getElementById('rightHtmlPanel')
        };

        // ============================================
        // INITIALIZATION
        // ============================================
        async function init() {
            console.log('üöÄ Initializing...');

            setupRenderer();
            setupCameras();
            setupControls();
            setupLights();
            setupPostProcessing();
            setupLoaders();

            await loadHDRI();
            await preloadAllModels(); // NEW: Load everything at start

            await checkVRSupport();
            setupEventListeners();

            renderer.setAnimationLoop(animate);

            DOM.loading.classList.add('hidden');
            DOM.backgroundImg.style.display = 'block';
            DOM.instructions.classList.add('visible');

            console.log('‚úÖ Ready');
        }

        function setupRenderer() {
            scene = new THREE.Scene();

            renderer = new THREE.WebGLRenderer({
                antialias: true,
                powerPreference: 'high-performance'
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.1;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            clock = new THREE.Clock();
            pmremGenerator = new THREE.PMREMGenerator(renderer);
            pmremGenerator.compileEquirectangularShader();
        }

        function setupCameras() {
            const aspect = window.innerWidth / window.innerHeight;

            perspectiveCamera = new THREE.PerspectiveCamera(CONFIG.defaultFOV, aspect, 0.1, 1000);

            const frustum = CONFIG.orthoFrustumSize;
            orthographicCamera = new THREE.OrthographicCamera(
                frustum * aspect / -2,
                frustum * aspect / 2,
                frustum / 2,
                frustum / -2,
                0.1,
                1000
            );

            camera = perspectiveCamera;

            scene.add(playerRig);
            playerRig.add(camera);

            audioListener = new THREE.AudioListener();
            camera.add(audioListener);
        }

        function setupControls() {
            orbitControls = new OrbitControls(camera, renderer.domElement);
            orbitControls.enabled = false;
            orbitControls.enableDamping = true;
            orbitControls.dampingFactor = 0.05;
            orbitControls.target.set(0, 1, 0);

            // Stop auto-rotate when user interacts
            orbitControls.addEventListener('start', () => {
                if (orbitControls.autoRotate) {
                    orbitControls.autoRotate = false;
                    console.log('Auto-rotate disabled by user interaction');
                }
            });

            pointerLockControls = new PointerLockControls(perspectiveCamera, renderer.domElement);
            scene.add(pointerLockControls.getObject());
        }

        function setupLights() {
            // Neutral hemisphere light (no pink tint)
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x8899aa, 0.3);
            hemiLight.position.set(0, 20, 0);
            scene.add(hemiLight);

            // Sun light - neutral white for realistic reflections
            const sunLight = new THREE.DirectionalLight(0xfff9f0, 2.8);
            sunLight.position.set(12, 24, 12);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.set(2048, 2048);
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 160;
            sunLight.shadow.camera.left = -55;
            sunLight.shadow.camera.right = 55;
            sunLight.shadow.camera.top = 55;
            sunLight.shadow.camera.bottom = -55;
            sunLight.shadow.bias = -0.0001;
            sunLight.shadow.normalBias = 0.025;
            scene.add(sunLight);

            // Subtle fill light
            const fillLight = new THREE.DirectionalLight(0xe8f4ff, 0.4);
            fillLight.position.set(-8, 10, -8);
            scene.add(fillLight);
        }

        function setupPostProcessing() {
            composer = new EffectComposer(renderer);

            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            const ssaoPass = new SSAOPass(scene, camera, window.innerWidth, window.innerHeight);
            ssaoPass.kernelRadius = 0.8;
            ssaoPass.minDistance = 0.001;
            ssaoPass.maxDistance = 0.05;
            composer.addPass(ssaoPass);

            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                0.3, 0.25, 0.9
            );
            composer.addPass(bloomPass);

            const outputPass = new OutputPass();
            composer.addPass(outputPass);
        }

        function setupLoaders() {
            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath(CONFIG.dracoPath);
            dracoLoader.setDecoderConfig({ type: 'js' });

            gltfLoader = new GLTFLoader();
            gltfLoader.setDRACOLoader(dracoLoader);
            gltfLoader.setMeshoptDecoder(MeshoptDecoder);
        }

        async function loadHDRI() {
            return new Promise((resolve) => {
                new RGBELoader().load(
                    CONFIG.hdri,
                    (texture) => {
                        texture.mapping = THREE.EquirectangularReflectionMapping;
                        scene.background = texture;
                        scene.environment = pmremGenerator.fromEquirectangular(texture).texture;
                        scene.environmentIntensity = 0.6;
                        texture.dispose();
                        console.log('‚úÖ HDRI loaded');
                        resolve();
                    },
                    undefined,
                    () => {
                        console.warn('HDRI failed, continuing...');
                        resolve();
                    }
                );
            });
        }

        // ============================================
        // PRE-LOAD ALL MODELS
        // ============================================
        async function preloadAllModels() {
            DOM.loadingProgress.textContent = 'Loading all models...';

            const loadPromises = CONFIG.models.map((url, index) => {
                return new Promise((resolve) => {
                    gltfLoader.load(
                        url,
                        (gltf) => {
                            const model = gltf.scene;
                            model.visible = false; // Hide by default

                            let mixer = null;
                            if (gltf.animations && gltf.animations.length > 0) {
                                mixer = new THREE.AnimationMixer(model);
                                gltf.animations.forEach(clip => mixer.clipAction(clip).play());
                            }

                            model.traverse((child) => {
                                if (child.isMesh) {
                                    child.castShadow = true;
                                    child.receiveShadow = true;
                                    if (child.material && child.material.emissive) {
                                        child.material.emissiveIntensity = 1;
                                    }
                                }
                            });

                            scene.add(model);
                            allModels[index] = { model, mixer };

                            console.log(`‚úÖ Model ${index} pre-loaded`);
                            DOM.loadingProgress.textContent = `Loaded ${Object.keys(allModels).length}/${CONFIG.models.length} models`;
                            resolve();
                        },
                        undefined,
                        (error) => {
                            console.error(`‚ùå Model ${index} failed:`, error);
                            resolve(); // Continue even if one fails
                        }
                    );
                });
            });

            await Promise.all(loadPromises);
            console.log('‚úÖ All models pre-loaded');
        }

        async function checkVRSupport() {
            try {
                const supported = navigator.xr && await navigator.xr.isSessionSupported('immersive-vr');
                if (supported) {
                    setupVR();
                } else {
                    setupDesktop();
                }
            } catch (e) {
                setupDesktop();
            }
        }

        function setupDesktop() {
            vrActive = false;
            document.body.addEventListener('click', onInitialClick, { once: true });
        }

        function setupVR() {
            vrActive = true;
            DOM.instructions.classList.remove('visible');

            const vrButton = VRButton.createButton(renderer);
            vrButton.textContent = 'Enter VR';
            document.body.appendChild(vrButton);

            const controllerModelFactory = new XRControllerModelFactory();
            for (let i = 0; i < 2; i++) {
                const controller = renderer.xr.getController(i);
                const grip = renderer.xr.getControllerGrip(i);
                grip.add(controllerModelFactory.createControllerModel(grip));
                playerRig.add(controller);
                playerRig.add(grip);
                vrControllers.push(controller);
            }

            renderer.xr.addEventListener('sessionstart', () => {
                experienceStarted = true;
                DOM.backgroundImg.style.display = 'none';
                runSequence();
            });

            renderer.xr.addEventListener('sessionend', () => {
                window.location.reload();
            });
        }

        function onInitialClick() {
            if (experienceStarted) return;
            experienceStarted = true;
            if (audioListener.context.state === 'suspended') {
                audioListener.context.resume();
            }
            runSequence();
        }

        // ============================================
        // SEQUENCE MANAGEMENT
        // ============================================
        async function runSequence() {
            currentScene++;
            console.log(`üé¨ Scene ${currentScene}`);

            DOM.sceneLoading.style.display = 'block';
            DOM.backgroundImg.style.display = 'block';
            hideAllUI();

            try {
                await executeScene(currentScene);
            } catch (error) {
                console.error(`‚ùå Scene ${currentScene} error:`, error);
            } finally {
                DOM.sceneLoading.style.display = 'none';
                DOM.backgroundImg.style.display = 'none';
            }

            console.log(`‚úÖ Scene ${currentScene} ready`);
        }

        async function executeScene(sceneNum) {
            // Hide all models first
            Object.values(allModels).forEach(({ model }) => {
                model.visible = false;
            });
            colliderMeshes = [];

            switch (sceneNum) {
                case 0: await scene0_PreStart(); break;
                case 1: await scene1_PostStart(); break;
                case 2: await scene2_DesignOptions(); break;
                case 3: await scene3_Orbit(); break;
                case 4: await scene4_Interior(); break;
                case 5: await scene5_Walkthrough(); break;
                case 6: window.location.reload(); break;
            }
        }

        async function scene0_PreStart() {
            DOM.instructions.classList.remove('visible');
            DOM.startButton.textContent = 'Start';
            DOM.startButton.style.display = 'block';

            showModel(0); // Model 1
            showModel(4); // Model 5

            setupCamera({
                type: 'orbit',
                cameraType: 'orthographic',
                pos: { x: 0, y: 20, z: 15 },
                lookAt: { x: 0, y: 1, z: 0 },
                autoRotate: true,
                autoRotateSpeed: 1.0,
                enableZoom: false,
                enableRotate: false
            });

            updatePanels('html_scene0_left', 'html_scene0_right');
        }

        async function scene1_PostStart() {
            DOM.startButton.textContent = 'Next';

            // Show main city models
            showModel(0); // Main city model with surroundings
            showModel(4); // Building model

            setupCamera({
                type: 'orbit',
                cameraType: 'orthographic',
                pos: { x: 0, y: 20, z: 15 },
                lookAt: { x: 0, y: 1, z: 0 },
                autoRotate: true,
                autoRotateSpeed: 1.0,
                enableZoom: true,
                enableRotate: true
            });

            setupToggles([
                { name: 'Surrounding', id: 'surrounding' },
                { name: 'Transportation', id: 'transportation' },
                { name: 'Units', id: 'units' }
            ]);

            handleToggleClick(0);
        }

        async function scene2_DesignOptions() {
            // Assign IDs to models
            if (allModels[0]) allModels[0].model.userData.id = 'm1';
            if (allModels[3]) allModels[3].model.userData.id = 'm4';
            if (allModels[2]) allModels[2].model.userData.id = 'm3';
            if (allModels[4]) allModels[4].model.userData.id = 'm5';

            setupCamera({
                type: 'orbit',
                cameraType: 'orthographic',
                pos: { x: 0, y: 30, z: 15 },
                lookAt: { x: 0, y: 4, z: 0 },
                autoRotate: true,
                enableZoom: true,
                enableRotate: true
            });

            setupToggles([
                { name: 'Option 1', id: 'view1' },
                { name: 'Option 2', id: 'view2' }
            ]);

            handleToggleClick(0);
        }

        async function scene3_Orbit() {
            showModel(2);
            showModel(5);

            setupCamera({
                type: 'orbit',
                cameraType: 'orthographic',
                pos: { x: 15, y: 8, z: -15 },
                lookAt: { x: 0, y: 4, z: 0 },
                autoRotate: false,
                enableZoom: true,
                enableRotate: true
            });

            setupToggles(null);
            updatePanels('html_scene3_left', 'html_scene3_right');
        }

        async function scene4_Interior() {
            showModel(6);

            setupToggles([
                { name: 'Salon', id: 'cam1' },
                { name: 'Kitchen', id: 'cam2' },
                { name: 'Bedroom 1', id: 'cam3' },
                { name: 'Bedroom 1 WC', id: 'cam4' },
                { name: 'Bedroom 2', id: 'cam5' },
                { name: 'Bedroom 2 WC', id: 'cam6' }
            ]);

            handleToggleClick(0);
        }

        async function scene5_Walkthrough() {
            showModel(6);

            // Setup collider
            if (allModels[7]) {
                const colliderModel = allModels[7].model;
                colliderModel.traverse((child) => {
                    if (child.isMesh) {
                        colliderMeshes.push(child);
                    }
                });
            }

            setupToggles(null);
            DOM.startButton.textContent = 'Restart';

            setupCamera({
                type: 'pointerlock',
                cameraType: 'perspective',
                pos: { x: 1.4, y: 1.6, z: -0.6 }
            });

            updatePanels('html_scene5_left', 'html_scene5_right');
        }

        // ============================================
        // MODEL VISIBILITY
        // ============================================
        function showModel(index) {
            if (allModels[index]) {
                allModels[index].model.visible = true;
            }
        }

        function setModelVisibility(id, visible) {
            Object.values(allModels).forEach(({ model }) => {
                if (model.userData.id === id) {
                    model.visible = visible;
                }
            });
        }

        // ============================================
        // TOGGLE HANDLER
        // ============================================
        function handleToggleClick(index) {
            DOM.modelToggles.forEach((btn, i) => {
                btn.classList.toggle('selected', i === index);
            });

            switch (currentScene) {
                case 1:
                    const concepts = ['opt1', 'opt2', 'opt3'];
                    updatePanels(
                        `html_scene1_${concepts[index]}_left`,
                        `html_scene1_${concepts[index]}_right`
                    );
                    DOM.description.textContent = DOM.modelToggles[index].textContent;
                    DOM.description.style.display = 'block';
                    break;

                case 2:
                    if (index === 0) {
                        setModelVisibility('m1', true);
                        setModelVisibility('m4', true);
                        setModelVisibility('m3', false);
                        setModelVisibility('m5', false);
                        updatePanels('html_scene2_opt1_left', 'html_scene2_opt1_right');
                    } else {
                        setModelVisibility('m1', false);
                        setModelVisibility('m4', false);
                        setModelVisibility('m3', true);
                        setModelVisibility('m5', true);
                        updatePanels('html_scene2_opt2_left', 'html_scene2_opt2_right');
                    }
                    DOM.description.textContent = `Design ${index + 1}`;
                    DOM.description.style.display = 'block';
                    break;

                case 4:
                    const cameras = [
                        { pos: { x: 1, y: 1.6, z: 1.6 }, look: { x: 1, y: 1.6, z: 1.5 }, fov: 80 },
                        { pos: { x: -2, y: 1.6, z: 3.1 }, look: { x: -2.1, y: 1.6, z: 3.2 }, fov: 80 },
                        { pos: { x: -2, y: 1.6, z: 0 }, look: { x: -2.1, y: 1.6, z: -0.1 }, fov: 80 },
                        { pos: { x: -2, y: 1.6, z: 2.1 }, look: { x: -2.1, y: 1.6, z: 2.2 }, fov: 80 },
                        { pos: { x: 4.4, y: 1.6, z: 0 }, look: { x: 4.5, y: 1.6, z: -0.1 }, fov: 80 },
                        { pos: { x: 3.9, y: 1.6, z: 3.7 }, look: { x: 4.0, y: 1.6, z: 3.8 }, fov: 80 }
                    ];

                    const cam = cameras[index];
                    setupCamera({
                        type: 'orbit',
                        cameraType: 'perspective',
                        pos: cam.pos,
                        lookAt: cam.look,
                        fov: cam.fov,
                        autoRotate: false,
                        enableZoom: true,
                        enableRotate: true
                    });

                    updatePanels(
                        `html_scene4_cam${index + 1}_left`,
                        `html_scene4_cam${index + 1}_right`
                    );
                    DOM.description.textContent = DOM.modelToggles[index].textContent;
                    DOM.description.style.display = 'block';
                    break;
            }
        }

        // ============================================
        // CAMERA SETUP
        // ============================================
        function setupCamera(config) {
            orbitControls.enabled = false;
            orbitControls.autoRotate = false;

            if (pointerLockControls.isLocked) {
                pointerLockControls.unlock();
            }

            let newCam = config.cameraType === 'orthographic' ? orthographicCamera : perspectiveCamera;
            if (config.type === 'pointerlock') {
                newCam = perspectiveCamera;
            }

            if (camera !== newCam) {
                if (playerRig.children.includes(camera)) {
                    playerRig.remove(camera);
                }
                camera = newCam;
                playerRig.add(camera);
                camera.add(audioListener);
                orbitControls.object = camera;

                composer.passes.forEach(pass => {
                    if (pass.camera) pass.camera = camera;
                });
            }

            const pos = config.pos || { x: 0, y: 5, z: 10 };
            const look = config.lookAt || { x: 0, y: 1, z: 0 };

            if (config.type === 'orbit') {
                camera.position.set(pos.x, pos.y, pos.z);
                camera.lookAt(look.x, look.y, look.z);

                orbitControls.target.set(look.x, look.y, look.z);
                orbitControls.autoRotate = config.autoRotate || false;
                orbitControls.autoRotateSpeed = config.autoRotateSpeed || 1.0;
                orbitControls.enablePan = config.enablePan !== undefined ? config.enablePan : false;
                orbitControls.enableZoom = config.enableZoom !== undefined ? config.enableZoom : true;
                orbitControls.enableRotate = config.enableRotate !== undefined ? config.enableRotate : true;
                orbitControls.maxPolarAngle = Math.PI / 2 * 0.98;

                if (config.cameraType === 'orthographic') {
                    const aspect = window.innerWidth / window.innerHeight;
                    const frustum = CONFIG.orthoFrustumSize;
                    camera.left = frustum * aspect / -2;
                    camera.right = frustum * aspect / 2;
                    camera.top = frustum / 2;
                    camera.bottom = frustum / -2;
                } else {
                    camera.fov = config.fov || CONFIG.defaultFOV;
                }
                camera.updateProjectionMatrix();

                orbitControls.enabled = true;
                orbitControls.update();

            } else if (config.type === 'pointerlock') {
                camera.fov = config.fov || CONFIG.defaultFOV;
                camera.updateProjectionMatrix();

                pointerLockControls.getObject().position.set(pos.x, pos.y, pos.z);
                playerVelocity.set(0, 0, 0);
                playerOnFloor = true;

                if (!vrActive) {
                    pointerLockControls.lock();
                }
            }
        }

        // ============================================
        // UI MANAGEMENT
        // ============================================
        function setupToggles(config) {
            if (config) {
                DOM.modelLabel.style.display = 'block';
                DOM.modelToggleContainer.classList.add('visible');

                DOM.modelToggles.forEach((btn, i) => {
                    if (i < config.length) {
                        btn.textContent = config[i].name;
                        btn.dataset.id = config[i].id;
                        btn.style.display = 'block';
                        btn.classList.remove('selected');
                    } else {
                        btn.style.display = 'none';
                    }
                });

                if (config.length > 0) {
                    DOM.modelToggles[0].classList.add('selected');
                }
            } else {
                DOM.modelLabel.style.display = 'none';
                DOM.modelToggleContainer.classList.remove('visible');
                DOM.modelToggles.forEach(btn => btn.style.display = 'none');
            }
        }

        function updatePanels(leftId, rightId) {
            const leftContent = document.getElementById(leftId);
            if (leftContent) {
                DOM.leftPanel.innerHTML = leftContent.innerHTML;
                DOM.leftPanel.classList.add('visible');
            } else {
                DOM.leftPanel.classList.remove('visible');
            }

            const rightContent = document.getElementById(rightId);
            if (rightContent) {
                DOM.rightPanel.innerHTML = rightContent.innerHTML;
                DOM.rightPanel.classList.add('visible');
            } else {
                DOM.rightPanel.classList.remove('visible');
            }
        }

        function hideAllUI() {
            DOM.modelLabel.style.display = 'none';
            DOM.modelToggleContainer.classList.remove('visible');
            DOM.modelToggles.forEach(btn => btn.style.display = 'none');
            DOM.description.style.display = 'none';
            DOM.leftPanel.classList.remove('visible');
            DOM.rightPanel.classList.remove('visible');
        }

        // ============================================
        // PLAYER PHYSICS
        // ============================================
        function updatePlayer(delta) {
            if (!pointerLockControls.isLocked) return;

            const playerPos = pointerLockControls.getObject().position;

            raycaster.set(playerPos, new THREE.Vector3(0, -1, 0));
            const floorHits = raycaster.intersectObjects(colliderMeshes);
            const onFloor = floorHits.length > 0 && floorHits[0].distance < CONFIG.playerHeight + 0.1;

            if (onFloor) {
                playerVelocity.y = Math.max(0, playerVelocity.y);
                if (keys.jump) {
                    playerVelocity.y = CONFIG.jumpVelocity;
                    keys.jump = false;
                }
                const floorDist = floorHits[0].distance;
                if (floorDist < CONFIG.playerHeight) {
                    playerPos.y += (CONFIG.playerHeight - floorDist);
                }
            } else {
                playerVelocity.y += CONFIG.gravity * delta;
            }

            playerPos.y += playerVelocity.y * delta;

            playerVelocity.x -= playerVelocity.x * 10.0 * delta;
            playerVelocity.z -= playerVelocity.z * 10.0 * delta;

            const direction = new THREE.Vector3();
            direction.z = Number(keys.forward) - Number(keys.backward);
            direction.x = Number(keys.right) - Number(keys.left);
            direction.normalize();

            if (keys.forward || keys.backward) playerVelocity.z -= direction.z * currentMoveSpeed * delta;
            if (keys.left || keys.right) playerVelocity.x -= direction.x * currentMoveSpeed * delta;

            pointerLockControls.moveRight(-playerVelocity.x * delta);
            pointerLockControls.moveForward(-playerVelocity.z * delta);

            const checkPos = new THREE.Vector3(playerPos.x, playerPos.y - CONFIG.playerHeight / 2, playerPos.z);
            const directions = [
                new THREE.Vector3(1, 0, 0),
                new THREE.Vector3(-1, 0, 0),
                new THREE.Vector3(0, 0, 1),
                new THREE.Vector3(0, 0, -1)
            ];

            directions.forEach(dir => {
                raycaster.set(checkPos, dir);
                const wallHits = raycaster.intersectObjects(colliderMeshes);
                if (wallHits.length > 0 && wallHits[0].distance < CONFIG.playerRadius) {
                    const penetration = CONFIG.playerRadius - wallHits[0].distance;
                    playerPos.x -= dir.x * (penetration + 0.01);
                    playerPos.z -= dir.z * (penetration + 0.01);
                    if (dir.x !== 0) playerVelocity.x = 0;
                    if (dir.z !== 0) playerVelocity.z = 0;
                }
            });

            raycaster.set(playerPos, new THREE.Vector3(0, -1, 0));
            const finalFloor = raycaster.intersectObjects(colliderMeshes);
            playerOnFloor = finalFloor.length > 0 && finalFloor[0].distance < CONFIG.playerHeight + 0.1;
        }

        // ============================================
        // EVENT LISTENERS
        // ============================================
        function setupEventListeners() {
            DOM.startButton.addEventListener('click', (e) => {
                e.stopPropagation();
                runSequence();
            });

            DOM.modelToggles.forEach((btn, i) => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handleToggleClick(i);
                });
            });

            document.addEventListener('keydown', (e) => {
                if (vrActive || !pointerLockControls.isLocked) return;

                switch (e.code) {
                    case 'KeyW': keys.forward = true; break;
                    case 'KeyS': keys.backward = true; break;
                    case 'KeyA': keys.left = true; break;
                    case 'KeyD': keys.right = true; break;
                    case 'Space': if (playerOnFloor) keys.jump = true; break;
                    case 'ShiftLeft':
                        keys.sprint = true;
                        currentMoveSpeed = CONFIG.baseMoveSpeed * CONFIG.sprintMultiplier;
                        break;
                    case 'KeyF':
                        if (!document.fullscreenElement) {
                            document.documentElement.requestFullscreen();
                        } else {
                            document.exitFullscreen();
                        }
                        break;
                }
            });

            document.addEventListener('keyup', (e) => {
                if (vrActive || !pointerLockControls.isLocked) return;

                switch (e.code) {
                    case 'KeyW': keys.forward = false; break;
                    case 'KeyS': keys.backward = false; break;
                    case 'KeyA': keys.left = false; break;
                    case 'KeyD': keys.right = false; break;
                    case 'Space': keys.jump = false; break;
                    case 'ShiftLeft':
                        keys.sprint = false;
                        currentMoveSpeed = CONFIG.baseMoveSpeed;
                        break;
                }
            });

            window.addEventListener('resize', () => {
                const aspect = window.innerWidth / window.innerHeight;

                perspectiveCamera.aspect = aspect;
                perspectiveCamera.updateProjectionMatrix();

                const frustum = CONFIG.orthoFrustumSize;
                orthographicCamera.left = frustum * aspect / -2;
                orthographicCamera.right = frustum * aspect / 2;
                orthographicCamera.top = frustum / 2;
                orthographicCamera.bottom = frustum / -2;
                orthographicCamera.updateProjectionMatrix();

                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // ============================================
        // ANIMATION LOOP
        // ============================================
        function animate() {
            const delta = clock.getDelta();

            if (orbitControls.enabled) {
                orbitControls.update(delta);
            }

            if (currentScene === 5 && !vrActive) {
                updatePlayer(delta);
            }

            Object.values(allModels).forEach(({ mixer }) => {
                if (mixer) mixer.update(delta);
            });

            if (renderer.xr.isPresenting) {
                renderer.render(scene, camera);
            } else {
                composer.render();
            }
        }

        // ============================================
        // START
        // ============================================
        init().catch(error => {
            console.error('Init failed:', error);
            DOM.loading.innerHTML = '<div class="loading-text">Error</div>';
        });
    </script>
</body>
</html>