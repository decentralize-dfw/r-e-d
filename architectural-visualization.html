<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Architectural Study</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #info-panel {
            position: absolute;
            top: 24px;
            left: 24px;
            background: rgba(20, 20, 20, 0.85);
            backdrop-filter: blur(8px);
            padding: 20px 24px;
            border-radius: 2px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            max-width: 280px;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        #info-panel h1 {
            font-size: 13px;
            font-weight: 600;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            color: #ffffff;
            margin-bottom: 12px;
        }

        #info-panel p {
            font-size: 12px;
            line-height: 1.6;
            color: #a0a0a0;
            margin-bottom: 8px;
        }

        #info-panel p:last-child {
            margin-bottom: 0;
        }

        #controls-panel {
            position: absolute;
            bottom: 24px;
            right: 24px;
            background: rgba(20, 20, 20, 0.85);
            backdrop-filter: blur(8px);
            padding: 16px;
            border-radius: 2px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            display: flex;
            flex-direction: column;
            gap: 8px;
            transition: opacity 0.3s ease;
        }

        .control-section {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .control-label {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            color: #707070;
            margin-bottom: 4px;
        }

        .control-button {
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.12);
            color: #d0d0d0;
            padding: 10px 16px;
            font-size: 11px;
            font-weight: 500;
            letter-spacing: 0.3px;
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
            text-align: left;
        }

        .control-button:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            color: #ffffff;
        }

        .control-button:active {
            background: rgba(255, 255, 255, 0.04);
            transform: translateY(1px);
        }

        .control-button.active {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
            color: #ffffff;
        }
    </style>
</head>
<body>
    <div id="info-panel"></div>
    <div id="controls-panel"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let animationFrameId;

        function initRenderer() {
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: false,
                powerPreference: 'high-performance'
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            document.body.appendChild(renderer.domElement);
        }

        window.addEventListener('resize', () => {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });

        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2a2a2a);
            scene.fog = new THREE.Fog(0x2a2a2a, 50, 150);
        }

        function initCamera() {
            const fov = 45;
            const aspect = window.innerWidth / window.innerHeight;
            const near = 0.1;
            const far = 1000;
            camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
            camera.position.set(35, 12, 35);
            camera.lookAt(0, 8, 0);
        }

        function initLighting() {
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(30, 50, 20);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -40;
            directionalLight.shadow.camera.right = 40;
            directionalLight.shadow.camera.top = 40;
            directionalLight.shadow.camera.bottom = -40;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 150;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.bias = -0.0001;
            scene.add(directionalLight);

            const ambientLight = new THREE.AmbientLight(0x404862, 0.6);
            scene.add(ambientLight);

            const hemisphereLight = new THREE.HemisphereLight(0x8899bb, 0x334455, 0.4);
            scene.add(hemisphereLight);
        }

        function createConcreteMaterial() {
            return new THREE.MeshStandardMaterial({
                color: 0xb0b0b0,
                roughness: 0.85,
                metalness: 0.0,
                flatShading: false
            });
        }

        function createMetalMaterial() {
            return new THREE.MeshStandardMaterial({
                color: 0x505058,
                roughness: 0.35,
                metalness: 0.8,
                flatShading: false
            });
        }

        function createGlassMaterial() {
            return new THREE.MeshPhysicalMaterial({
                color: 0xaaccdd,
                metalness: 0.0,
                roughness: 0.1,
                transmission: 0.9,
                thickness: 0.5,
                transparent: true,
                opacity: 0.3
            });
        }

        function createArchitecture() {
            const building = new THREE.Group();

            const concreteMat = createConcreteMaterial();
            const metalMat = createMetalMaterial();
            const glassMat = createGlassMaterial();

            const baseGeom = new THREE.BoxGeometry(20, 0.8, 20);
            const base = new THREE.Mesh(baseGeom, concreteMat);
            base.position.y = 0.4;
            base.castShadow = true;
            base.receiveShadow = true;
            building.add(base);

            const mainVolumeGeom = new THREE.BoxGeometry(16, 12, 16);
            const mainVolume = new THREE.Mesh(mainVolumeGeom, concreteMat);
            mainVolume.position.set(0, 6.8, 0);
            mainVolume.castShadow = true;
            mainVolume.receiveShadow = true;
            building.add(mainVolume);

            const upperVolumeGeom = new THREE.BoxGeometry(12, 6, 10);
            const upperVolume = new THREE.Mesh(upperVolumeGeom, concreteMat);
            upperVolume.position.set(2, 16, -1);
            upperVolume.castShadow = true;
            upperVolume.receiveShadow = true;
            building.add(upperVolume);

            for (let floor = 0; floor < 3; floor++) {
                for (let i = 0; i < 4; i++) {
                    const windowGeom = new THREE.BoxGeometry(2.5, 2.8, 0.15);
                    const window = new THREE.Mesh(windowGeom, glassMat);
                    const x = -6 + i * 4;
                    const y = 3.2 + floor * 3.8;
                    window.position.set(x, y, 8.1);
                    window.castShadow = false;
                    window.receiveShadow = false;
                    building.add(window);

                    const windowBack = window.clone();
                    windowBack.position.set(x, y, -8.1);
                    building.add(windowBack);
                }
            }

            const accentGeom = new THREE.BoxGeometry(0.3, 18, 16.2);
            const accent = new THREE.Mesh(accentGeom, metalMat);
            accent.position.set(-8.2, 9.8, 0);
            accent.castShadow = true;
            accent.receiveShadow = true;
            building.add(accent);

            const roofEdgeGeom = new THREE.BoxGeometry(12.4, 0.4, 10.4);
            const roofEdge = new THREE.Mesh(roofEdgeGeom, metalMat);
            roofEdge.position.set(2, 19.2, -1);
            roofEdge.castShadow = true;
            roofEdge.receiveShadow = true;
            building.add(roofEdge);

            const groundGeom = new THREE.PlaneGeometry(100, 100);
            const groundMat = new THREE.MeshStandardMaterial({
                color: 0x3a3a3a,
                roughness: 0.9,
                metalness: 0.0
            });
            const ground = new THREE.Mesh(groundGeom, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0;
            ground.receiveShadow = true;
            scene.add(ground);

            scene.add(building);
        }

        function initUI() {
            const infoPanel = document.getElementById('info-panel');
            infoPanel.innerHTML = `
                <h1>Study 01</h1>
                <p>Stepped volume composition</p>
                <p>Concrete, metal, glass</p>
                <p>Height: 19.2m / Footprint: 20Ã—20m</p>
            `;

            const controlsPanel = document.getElementById('controls-panel');
            controlsPanel.innerHTML = `
                <div class="control-section">
                    <div class="control-label">Viewpoints</div>
                    <button class="control-button" data-view="default">Primary View</button>
                    <button class="control-button" data-view="front">Front Elevation</button>
                    <button class="control-button" data-view="top">Plan View</button>
                    <button class="control-button" data-view="detail">Detail Study</button>
                </div>
            `;

            const buttons = controlsPanel.querySelectorAll('.control-button');
            buttons.forEach(btn => {
                btn.addEventListener('click', () => {
                    buttons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    const view = btn.dataset.view;
                    transitionToView(view);
                });
            });

            buttons[0].classList.add('active');
        }

        const cameraStates = {
            target: new THREE.Vector3(0, 8, 0),
            currentPosition: new THREE.Vector3(),
            targetPosition: new THREE.Vector3(),
            currentLookAt: new THREE.Vector3(),
            targetLookAt: new THREE.Vector3(),
            transitioning: false,
            transitionProgress: 0,
            transitionSpeed: 0.02
        };

        const viewpoints = {
            default: { pos: [35, 12, 35], look: [0, 8, 0] },
            front: { pos: [0, 10, 45], look: [0, 10, 0] },
            top: { pos: [0, 60, 0.1], look: [0, 0, 0] },
            detail: { pos: [15, 16, 15], look: [2, 16, -1] }
        };

        function transitionToView(viewName) {
            const view = viewpoints[viewName];
            if (!view) return;

            cameraStates.currentPosition.copy(camera.position);
            cameraStates.targetPosition.set(...view.pos);
            cameraStates.currentLookAt.copy(cameraStates.target);
            cameraStates.targetLookAt.set(...view.look);
            cameraStates.transitioning = true;
            cameraStates.transitionProgress = 0;
        }

        function updateCameraTransition() {
            if (!cameraStates.transitioning) return;

            cameraStates.transitionProgress += cameraStates.transitionSpeed;

            if (cameraStates.transitionProgress >= 1) {
                cameraStates.transitionProgress = 1;
                cameraStates.transitioning = false;
            }

            const t = easeInOutCubic(cameraStates.transitionProgress);

            camera.position.lerpVectors(cameraStates.currentPosition, cameraStates.targetPosition, t);
            cameraStates.target.lerpVectors(cameraStates.currentLookAt, cameraStates.targetLookAt, t);
            camera.lookAt(cameraStates.target);
        }

        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let spherical = { radius: 45, theta: Math.PI / 4, phi: Math.PI / 3.5 };

        function initOrbitControls() {
            renderer.domElement.addEventListener('mousedown', (e) => {
                if (cameraStates.transitioning) return;
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            window.addEventListener('mousemove', (e) => {
                if (!isDragging || cameraStates.transitioning) return;

                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;

                spherical.theta -= deltaX * 0.005;
                spherical.phi -= deltaY * 0.005;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));

                updateCameraFromSpherical();

                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            window.addEventListener('mouseup', () => {
                isDragging = false;
            });

            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                if (cameraStates.transitioning) return;

                spherical.radius += e.deltaY * 0.05;
                spherical.radius = Math.max(10, Math.min(80, spherical.radius));

                updateCameraFromSpherical();
            });
        }

        function updateCameraFromSpherical() {
            const x = spherical.radius * Math.sin(spherical.phi) * Math.cos(spherical.theta);
            const y = spherical.radius * Math.cos(spherical.phi);
            const z = spherical.radius * Math.sin(spherical.phi) * Math.sin(spherical.theta);

            camera.position.set(x, y, z);
            cameraStates.target.set(0, 8, 0);
            camera.lookAt(cameraStates.target);
        }

        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            updateCameraTransition();
            renderer.render(scene, camera);
        }

        function init() {
            try {
                initRenderer();
                initScene();
                initCamera();
                initLighting();
                createArchitecture();
                initUI();
                initOrbitControls();
                animate();
            } catch (error) {
                console.error('Initialization error:', error);
                document.body.innerHTML = '<div style="color: white; padding: 20px;">Error initializing visualization. Please refresh the page.</div>';
            }
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>
